# Map = [[0, 1, 1, 0], [0, 0, 0, 1], [1, 1, 0, 0], [1, 1, 1, 0]]
# Map = [[0, 0, 0, 0, 0, 0],
# [1, 1, 1, 1, 1, 0],
# [0, 0, 0, 0, 0, 0],
# [0, 1, 1, 1, 1, 1],
# [0, 1, 1, 1, 1, 1],
# [0, 0, 0, 0, 0, 0]]
Map = [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
[1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
[1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
[1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
[1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
[1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
[1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]
# Map = [
# [0, 0, 0, 0, 0, 0, 1, 0, 0],
# [1, 1, 1, 1, 1, 0, 0, 1, 0],
# [0, 0, 1, 0, 0, 0, 0, 0, 0],
# [0, 0, 0, 0, 1, 1, 0, 0, 0],
# [0, 1, 1, 1, 1, 1, 1, 1, 1],
# [0, 0, 0, 0, 0, 0, 0, 0, 0]]

# If end is reached from start, minimize? Currently running alg up to twice
# min() ISN'T FASTER

# Label every open square with distance to start and distance to end
# Remove tile if one of those is greater than the shortest path - 2
# For every wall with 2 neighbors in the new tiling system
#   Add the lower distance to start + lower distance to end + 1 (might be from the same one)
# Optimize as to not do the +1 each time and such
#

# Maybe cache, save path from each thing
# Find way to only go down and right (or other way), store other possible moves, and then execute those.
# labelMap:
#   moves = labelMapRecursive(., ., ., [])
#   while moves != []: #find way to check empty
        #  moves.append(labelMapRecursive(moves.pop())) #
# labelMapRecursive(...):
#   moves = []
#   if elegible:
#     right, down
#     moves.append(up, left)
#     moves.append(labelMapRecursive)
#   return moves



w, h, width, height, minVal = 0, 0, 0, 0, 0
maze, attempts, paths = [], [], []
minAchieved = False
# Reduce function calls
def adjacent(coords):
    out = []
    if coords[0] != w:
        out.append([coords[0]+1, coords[1]])
    if coords[1] != h:
        out.append([coords[0], coords[1]+1])
    if coords[0] != 0:
        out.append([coords[0]-1, coords[1]])
    if coords[1] != 0:
        out.append([coords[0], coords[1]-1])
    return out
    # order matters

def labelRecursiveEfficient(current, coords):
    global minAchieved #faster?
    moves = []
    maze[coords[0]][coords[1]] = current
    if coords[0] != w:
        adjSpot = maz[coords[0]+1][coords[1]]
        if adjSpot == 0 or (adjSpot != -1 and adjSpot > current):
            nextVal = current + 1
            newMoves = labelRecursiveEfficient(nextVal, adj)
            if newMoves != []: moves.append(newMoves)
            if minAchieved: return
    elif coords[1] == h-1:
        paths.append(current + 1)
        if nextVal == minVal:
            minAchieved = True
        return
    if coords[1] != h:
        adjSpot = maz[coords[0]][coords[1]+1]
        if adjSpot == 0 or (adjSpot != -1 and adjSpot > current):
            nextVal = current + 1
            newMoves = labelRecursiveEfficient(nextVal, adj)
            if newMoves != []: moves.append(newMoves)
            if minAchieved: return
    elif coords[0] == w - 1:
        paths.append(current + 1)
        if nextVal == minVal:
            minAchieved = True
        return
    if coords[1] != 0:
        adjSpot = maz[coords[0]][coords[1]-1]
        if adjSpot == 0 or (adjSpot != -1 and adjSpot > current):
            moves.append([coords[0], coords[1]-1])
    if coords[0] != 0:
        adjSpot = maz[coords[0]-1][coords[1]]
        if adjSpot == 0 or (adjSpot != -1 and adjSpot > current):
            moves.append([coords[0]-1, coords[1]])
    return moves

def labelRecursive(current, coords):
    global minAchieved #faster?
    maze[coords[0]][coords[1]] = current
    adjs = []
    if coords[0] != w:
        adjs.append([coords[0]+1, coords[1]])
    elif coords[1] == h-1:
        paths.append(current + 1)
        if nextVal == minVal:
            minAchieved = True
        return
    if coords[1] != h:
        adjs.append([coords[0], coords[1]+1])
    elif coords[0] == w-1:
        paths.append(current + 1)
        if nextVal == minVal:
            minAchieved = True
        return
    if coords[1] != 0:
        adjs.append([coords[0], coords[1]-1])
    if coords[0] != 0:
        adjs.append([coords[0]-1, coords[1]])
    for adj in adjs:
        adjSpot = maze[adj[0]][adj[1]]
        if adjSpot == 0 or (adjSpot != -1 and adjSpot > current):
            nextVal = current + 1
            labelRecursive(nextVal, adj)
            if minAchieved: return

def labelRecursiveBackwards(current, coords):
    mazeBack[coords[0]][coords[1]] = current
    # adjs = adjacent(coords)
    adjs = []
    if coords[0] != w:
        adjs.append([coords[0]+1, coords[1]])
    if coords[1] != h:
        adjs.append([coords[0], coords[1]+1])
    if coords[1] != 0:
        adjs.append([coords[0], coords[1]-1])
    if coords[0] != 0:
        adjs.append([coords[0]-1, coords[1]])
    for adj in adjs:
        adjSpot = mazeBack[adj[0]][adj[1]]
        if adjSpot == 0 or (adjSpot != -1 and adjSpot > current):
            nextVal = current + 1
            if adj == [0, 0]: return
            # optimize as to just spread from a reached point on normal maze?
            labelRecursiveBackwards(nextVal, adj)

def labelMap(Map):
    global maze, mazeBack
    maze = [[-element for element in row] for row in Map]
    mazeBack = [[-element for element in row] for row in Map] #optimize
    moves = labelRecursive(1, [0, 0])
    def movesNotEmpty(moves):
        return
    while movesNotEmpty:
        newMoves = labelMapRecursive(moves.pop())
        for i in range(len(newMoves)):
            if newMoves[i]  + moves#

    labelRecursiveBackwards(1, [w, h])
    # print "maze --->"
    # for row in maze:
    #     print row
    # print "maze <---"
    # for row in mazeBack:
    #     print row

def checkWall(wall, adjs):
    lowFor = min([maze[adj[0]][adj[1]] for adj in adjs if maze[adj[0]][adj[1]] != 0] + [1024])
    lowBack = min([mazeBack[adj[0]][adj[1]] for adj in adjs if mazeBack[adj[0]][adj[1]] != 0] + [1024])
    global attempts
    attempts = attempts + [lowFor + lowBack] #add 1 later

def findWallsFiltered(Map):
    walls = []
    for i in range(w):
        for j in range(h):
            if Map[i][j] == 1:
                adjOpen = [adj for adj in adjacent([i,j]) if Map[adj[0]][adj[1]] == 0]
                if len(adjOpen) > 1:
                    walls.append([[i,j], adjOpen])
    return walls

def answer(Map):
    global w, h, maze, attempts #necessary?
    width, height = len(Map), len(Map[0])
    w, h = width - 1, height - 1
    minVal = width + h
    labelMap(Map)
    attempts = []
    if len(paths) != 0:
        attempts.append(min(paths) - 1) #will add 1 back later
    if minAchieved: return minVal
    for wall in findWallsFiltered(Map):
        checkWall(wall[0], wall[1])
        if minAchieved: return minVal
    best = min(attempts) + 1
    return best

print answer(Map)
